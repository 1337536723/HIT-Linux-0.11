# 信号量的实现与应用

1. [实验内容](#实验内容)
2. [实验过程](#实验过程)
	- [实验结果](#实验结果)
	- [实验分析](#实验分析)
		1. [从生产者-消费者问题看进程同步](#1-从生产者-消费者问题看进程同步)
			1. [信号量实现进程同步](#11-信号量实现进程同步)
			2. [靠临界区保护信号量](#12-靠临界区保护信号量)
				1. [竞争条件(Race Condition)](#121-竞争条件race-condition)
				2. [通过锁机制实现临界区的原子性访问](#122-通过锁机制实现临界区的原子性访问)
		2. [用信号量解决生产者-消费者问题](#2-用信号量解决生产者-消费者问题)
			1. [用文件作为一个共享缓冲区](#21-用文件作为一个共享缓冲区)
			2. [多个消费者进程读数的文件偏移量同步及读取结束判断](#22-多个消费者读数的文件偏移量同步及读取结束判断)
		3. [信号量的实现](#信号量的实现)
			1. [信号量的组成](#信号量的组成)
			2. [等待队列的构造](#等待队列的构造)

## 实验内容
1. 在Ubuntu下编写程序，用信号量解决生产者-消费者问题    
  在Ubuntu下编写应用程序`pc.c`，解决经典的生产者-消费者问题，完成下面的功能：    
    - 建立一个生产者进程，N个消费者进程(N > 1)
    - 用文件建立一个共享缓冲区
    - 生产者进程依次向缓冲区写入整数0,1,2,...,M, M >= 500
    - 消费者进程从缓冲区读数，每次读一个，并将读出的数字从缓冲区删除，然后将本进程ID+数字输出到标准输出
    - 缓冲区同时最多只能保存10个数    
  `pc.c`中将会用到`sem_open()`,`sem_unlink()`,`sem_wait()`,`sem_post()`等信号量相关的系统调用，请查阅相关文档。    
2. 在0.11中实现信号量，用生产者-消费者程序检验之    
  Linux在0.11版还没有实现信号量，Linus把这件富有挑战的工作留给了你。如果能够实现一套山寨版的完全符合POSIX规范的信号量，无疑是很有成就感的。但时间暂时不允许我们这么做，所以先弄一套缩水版的类POSIX信号量，它的原型和标准并不完全相同，而且只包含如下系统调用：    
    ```c
    sem_t *sem_open(const char *name, unsigned int value);
    int sem_wait(sem_t *sem);
    int sem_post(sem_t *sem);
    int sem_unlink(const char *name);
    ```

    - `sem_t`是信号量类型，根据实现的需要自定义
    - `sem_open`    
      功能是创建一个信号量，或打开一个已经存在的信号量。
	  `name`是信号量的名字。不同的进程可以通过提供同样的`name`而共享同一个信号量。如果该信号量不存在，就创建新的名为`name`的信号量；如果存在，就打开已经存在的名为`name`的信号量。    
	  `value`是信号量的初值，仅当新建信号量时，此参数才有效，其余情况下它被忽略。    
	  当成功时，返回值是该信号量的唯一标识(比如，在内核的地址，ID等)，由另外两个系统调用使用。如失败，返回值是NULL。    
    - `sem_wait`    
      信号量的P原子操作。如果继续运行的条件不满足，则令调用进程等待在信号量`sem`上。    
	  返回0表示成功，返回-1表示失败。    
    - `sem_post`    
      信号量的V原子操作。如果有等待`sem`的进程，它会唤醒其中的一个。返回0表示成功，返回-1表示失败。    
    - `sem_unlink`    
      功能是删除名为`name`的信号量。返回0表示成功，返回-1表示失败。    
  在*kernel*目录下新建`sem.c`文件实现如下功能。然后将`pc.c`从Ubuntu移植到0.11下，测试自己实现的信号量。    
3. 实验报告    
    1. 在`pc.c`中去掉所有与信号量有关的代码，再运行程序，执行效果有变化吗？为什么会这样？    
    2. 实验的设计者在第一次编写生产者-消费者程序的时候，是这么做的：
        ```c
        Producer()
	    {
		    P(Mutex);  //互斥信号量
		    生产一个产品item;
		    P(Empty);  //空闲缓存资源
		    将item放到空闲缓存中;
		    V(Full);  //产品资源
		    V(Mutex);
  	    }

	    Consumer()
	    {
		    P(Mutex);  
		    P(Full);  
		    从缓存区取出一个赋值给item;
		    V(Empty);
		    消费产品item;
		    V(Mutex);
	    }
	    ```
        这样可行吗？如果可行，那么它和标准解法在执行效果上会有什么不同？如果不可行，那么它有什么问题使它不可行？    

## 实验过程    

### 实验结果    
1. 在Ubuntu上运行pc.c的结果：    
  ![Ubuntu上pc.c的执行结果](https://github.com/Wangzhike/HIT-Linux-0.11/raw/master/5-semaphore/picture/result-on-ubuntu.png)

2. 在添加了实现信号量的0.11上运行移植好的pc.c的结果：    
  ![编译执行移植好的pc.c](https://github.com/Wangzhike/HIT-Linux-0.11/raw/master/5-semaphore/picture/experiment-result.png)
  ![执行结果](https://github.com/Wangzhike/HIT-Linux-0.11/raw/master/5-semaphore/picture/experiment-result-2.png)

### 实验分析

#### 1. 从生产者-消费者问题看进程同步    

##### 1.1 信号量实现进程同步    
生产者负责往缓冲区写入数据，消费者从缓冲区取走生产者写入的数据，缓冲区就是这个过程的共享资源。如果生产者还不曾向缓冲区写入数据，消费者就从缓冲区读取；或者生产者数据写入还未完成，消费者就读取。这两种情况消费者读取到的都是非法数据。如果缓冲区已满，生产者继续往其中写入数据，就会覆盖尚未被消费者读取的数据，造成数据丢失。就像多人参与的项目需要分工协调，多个进程对共享资源的使用也必须进行同步。进程同步就是让进程在必要的地方停下来，等待其他进程执行到满足一定的条件后，再继续执行，从而保证多个进程合理有序的推进。    
就生产者-消费者问题，进程同步就是要保证：    
    对于生产者来说，当缓冲区满，也就是空闲缓冲区个数为0时，此时生产者不能继续向缓冲区写数，必须等待，直到有消费者从满缓冲区取走数后，再次有了空闲缓冲区，生产者才能向缓冲区写数。并且当缓冲区满时，先后有多个生产者均想往缓冲区写入，那么它们均需要等待，此时需要记录下等待的生产者的个数，以便缓冲区有空闲空间后，所有等待的生产者都会得到唤醒，确保请求写入的生产者最终都能写入到缓冲区。    
    对于消费者来说，当缓冲区空时，此时没有数可以被取走，消费者必须等待，直到有生产者向缓冲区写数后，消费者才能取数。并且如果当缓冲区空时，先后有多个消费者均想从缓冲区取数，那么它们均需要等待，此时需要记录下等待的消费者的个数，以便缓冲区有数可取后，所有等待的消费者都会得到唤醒，确保请求取数的消费者最终都能取到数。    
也就是说，当多个进程需要协同合作时，需要根据某个信息，判断当前进程是否需要停下来等待；同时，其他进程需要根据这个信息判断是否有进程在等待，或者有几个进程在等待，以决定是否需要唤醒等待的进程。而这个信息，就是信号量。    
**信号量是一个计数器，用于为多个进程提供对共享数据对象的访问**。为了获得共享资源，进程需要执行下列操作：    
1. 测试控制该资源的信号量。    
2. 若此信号量的值为正，则进程可以使用该资源。在这种情况下，进程会将信号量值减1，表示它使用了一个共享资源。    
3. 否则，若此信号量的值为0，则进程进入休眠状态，直至信号量值大于0。如果有进程正在休眠等待此信号量，则唤醒它们。    

在实现信号量时，信号量可以取到负值，通过这个负值的大小，可以知道有几个进程正在休眠等待此信号量。比如下面的情况：    
设有一整形变量sem，作为一个信号量。此时缓冲区为空，sem=0。	
1.	消费者C1请求从缓冲区取数，不能取到，睡眠等待。sem=-1<0，表示有一个进程因缺资源而等待。
2. 消费者C2也请求从缓冲区取数，睡眠等待。sem=-2<0，表示有两个进程因缺资源而等待。
3. 生产者P往缓冲区写入一个数，sem=sem+1=-1<=0，并唤醒等待队列的头进程C1，C1处于就绪态，C2仍处于睡眠等待。
4. 生产者P继续往缓冲区写入一个数，sem=0<=0，并唤醒C2，C1、C2就处于就绪状态。

##### 1.2 靠临界区保护信号量

###### 1.2.1 竞争条件(Race Condition)    
为了正确实现信号量，信号量值的测试及加减1操作应当是原子操作。**原子操作不可分割，在执行时不会因为调度被打断，也就是说，原子操作的一系列指令要么一次执行完成，要么没有执行，不会出现执行一部分而被切换出去**。如果信号量的操作不是原子的，就会发生问题。我们考虑以下代码：    
```c
x++;	//x is an integer
```
该`++`操作符是个后增操作符，我们都知道它会执行什么操作：获取当前的`x`值，把`x`值加1，把加1后的新的值再保存到`x`中，该表达式的返回值即更新后的`x`值。该操作如何编译成机器码取决于架构，它看起来可能如下：    
```c
load x into reigster
add 1 to register
store register in x
```
假设有两个生产者同时对缓冲区可用资源数full进行`full++`操作，其中`full = 5`。以下是期望的输出：    

| 时间	| 生产者1				| 生产者2				|
| :---:	| :---:					| :---:					|
| 1		| 把full加载到寄存器(5)	| 						|
| 2		| 寄存器值加1(6)		| 						|
| 3		| 把寄存器值赋给full(6)	| 						|
| 4		|						| 把full加载到寄存器(6)	|
| 5		| 						| 寄存器加1(7)			|
| 6		| 						| 把寄存器值赋给full(7)	|

但是，我们无法避免下面的情况：    

| 时间	| 生产者1				| 生产者2				|
| :---:	| :---:					| :---:					|
| 1		| 把full加载到寄存器(5)	| 						|
| 2		| 寄存器值加1(6)		| 						|
| 3		| 						| 把full加载到寄存器中(5)	|
| 4		| 把寄存器值赋给full(6)	| 						|
| 5		| 						| 寄存器加1(6)			|
| 6		| 						| 把寄存器值赋给full(6)	|

很多其他组合也会带来不期望的结果。    
`full++`就是竞争条件。**竞争条件(race condition)是指：当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序，我们认为发生了竞争条件**。    
共享资源可以是以下任意一种：系统硬件、内核资源或内存中的数据。后者是最常见的，称为数据竞争(data reace)。    
**竞争所发生的窗口——需要同步的代码区，称为临界区**。竞争的最根本的源头在于临界区是个窗口，在这个窗口内，正确的程序行为要求多个进程不要交替执行。为了阻止竞争条件，需要在这个窗口内执行同步访问操作，**确保多个进程对临界区以互斥的方式访问**。也就是说要让临界区成为一个原子操作。    

###### 1.2.2 通过锁机制实现临界区的原子性访问
实现临界区原子性访问的技术有很多，最常见的技术是锁。我们定义锁，并确保在进入临界区之前获取该锁。锁的实现机制确保一次只能持有一个锁。如果有另一个进程使用锁，新的进程在继续之前必须等待。如果不在临界区，就释放锁，让等待进程(如果有的话)持有锁并继续执行。    
锁的实现有几种方法：    
1. 软件方法
    - 适用于两个进程的Peterson算法
    - 适用于多个进程的面包店算法
2. 硬件方法
    - 适用于单CPU的开关中断方法
    - 硬件原子指令法

在Linux 0.11上比较简单的方法就是通过开关中断来阻止时钟中断，从而避免时间片耗完引发的调度，来实现临界区的原子性访问。但是开关中断的方法，只适合单CPU的情况，对于多CPU的情况，不适用。Linux 0.11就是单CPU，可以使用这种方法。    

#### 2. 用信号量解决生产者-消费者问题

##### 2.1 用文件作为一个共享缓冲区


##### 2.2 多个消费者读数的文件偏移量同步及读取结束判断

#### 3. 信号量的实现

##### 3.1 信号量的组成

##### 3.2 等待队列的构造

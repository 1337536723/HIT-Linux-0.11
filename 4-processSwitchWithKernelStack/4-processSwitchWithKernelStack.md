# 基于内核栈切换的进程切换

1. [实验内容](#实验内容)
2. [实验过程](#实验过程)
    - [实验结果](#实验结果)
	- [实验分析](#实验分析)
	    1. [为什么要从基于TSS的任务切换改为基于内核栈切换的任务切换](#1-为什么要从基于tss的任务切换改为基于内核栈切换的任务切换)
		2. [是否还需要任务状态段TSS](#2-是否还需要任务状态段tss)
		3. [中断和异常的硬件处理](#3-中断和异常的硬件处理)
		4. [进程切换的五段论](#4-进程切换的五段论)
		    1. [利用中断进入内核引起用户栈到内核栈的切换](#41-利用中断进入内核引起用户栈到内核栈的切换)
			2. [引发调度时通过内核栈找到PCB](#42-引发调度时通过内核栈找到pcb)
			3. [找到下一个进程的PCB完成PCB的切换](#43-找到下一个进程的pcb完成pcb的切换)
			4. [通过PCB找到内核栈完成内核栈的切换](#44-通过PCB找到内核栈完成内核栈的切换)
			5. [通过内核栈找到用户栈利用iret中断返回到用户态程序和用户栈](#45-通过内核栈找到用户栈利用iret中断返回到用户态程序和用户栈)

## 实验内容

## 实验过程

### 实验结果

### 实验分析

#### 1. 为什么要从基于TSS的任务切换改为基于内核栈切换的任务切换
Linux 0.11利用80x86硬件提供的机制：通过执行`ljmp next进程TSS描述符的选择符, (无用的)偏移地址`指令来进行任务切换。这种切换机制的特点正如实验手册所说：    
> 现在的Linux 0.11采用TSS和一条指令就能完成任务切换，虽然简单，但这条指令的执行时间却很长，在实现任务切换时需要200多个时钟周期(一个任务的时间片只有15个时钟周期)。而通过堆栈实现任务切换可能要更快，而且采用堆栈的切换还可以使用指令流水的并行优化技术，同时又使得CPU的设计变得简单。所以无论是Linux还是Windows，进程/线程的切换都没有使用Intel提供的这种TSS切换手段，而都是通过堆栈实现的。   

存在切换时间长，依赖CPU指令支持，单一指令切换无法使能指令流水的并行优化这些问题。而从课程的讲解我们知道：对于函数调用，依靠栈进行返回地址保存和弹栈返回操作；对于用户级线程，每个线程拥有一个线程控制块TCB，TCB关联着用户栈，TCB切换引起用户栈跟着切换，实现从一个线程切换到另一个线程以及再次切换回这个被换出的线程；对于核心级线程，线程切换发生在内核，从用户态进入内核态首先要发生线程用户栈到内核栈的切换，线程的TCB关联着内核栈，TCB切换引起内核栈切换，利用`iret`指令进行中断返回会引起内核栈中用户态参数的出栈，从而实现执行流程转移到新进程的用户态指令和用户栈。这些例子充分说明了栈在指令流程切换中的关键作用，再参照内核`main`函数完成初始化工作后，[以模拟特权级发生变化的内核中断返回的方式手动切换到任务0执行](https://github.com/Wangzhike/HIT-Linux-0.11/blob/master/3-processTrack/3-processTrack.md#13-以模拟从特权级发生变化的内核中断处理过程返回的方式手动切换到任务0去执行)，完全可以自己想出是可以利用内核栈切换的方式实现进程切换的。    

#### 2. 是否还需要任务状态段TSS
虽然不再使用`ljmp TSS段选择符的选择子, (不使用的)段内偏移`进行任务切换，但Intel的中断处理机制仍需要保持，因为CPU正是依靠这种机制才能在中断处理时找到内核栈，并将用户态下的`SS:ESP, EFLAGS, CS:EIP`这5个寄存器的值自动压入到内核栈中，这是沟通用户栈(用户态)和内核栈(内核态)的关键桥梁。具体处理过程参见[3. 中断和异常的硬件处理](#3-中断和异常的硬件处理)。所以仍然需要有一个当前TSS，这个TSS就是需要我们额外定义的全局变量tss，即0号进程的tss，所有进程都共用这个tss，任务切换时不再发生变化。    

#### 3. 中断和异常的硬件处理
在实验2：系统调用的[从Linux 0.11自带的库函数入手追寻系统调用的实现过程](https://github.com/Wangzhike/HIT-Linux-0.11/blob/master/2-syscall/2-syscall.md#1-从linux-011自带的库函数入手追寻系统调用的实现过程)中介绍的中断或异常的处理过程我们已经知道，当特权级发生变化时，也就是说，当前特权级CPL(存放在CS寄存器的低两位)不同于所选择的段描述符的DPL(从GDT表中获取的段描述符中的描述符特权级DPL)，控制单元必须开始使用与新的特权级相关的栈，要发生栈的切换。通过执行以下步骤来做到这点：    
1. 读`TR`寄存器，里面保存了`TSS`段的选择子，利用该选择子在GDT表中找到运行进程的TSS段的内存位置。    
2. 在`TSS`段中找到新特权级相关的栈段和栈指针即`ss0`和`esp0`，将它们装载到`ss`和`esp`寄存器。    
3. 在新的栈中保存`ss`和`esp`以前的值，这些值定义了旧特权级相关的栈的逻辑地址。形象点说，就是在新栈和旧栈之间拉了一条线，形成了一套栈。    
4. 如果故障已发生，用引起异常的指令地址装载`cs`和`eip`寄存器，从而使得这条指令能再次执行。    
5. 在栈中保存`eflags`,`cs`,`eip`的内容。   

而在中断或异常处理完毕后，相应的处理程序必须产生一条`iret`指令，把控制权转交给被中断的进程，这将迫使控制单元：    
1. 用保存在栈中的值装载`cs`,`eip`和`eflags`寄存器。如果一个硬件出错码曾被压入栈中，并且在`eip`内容的下面，那么，在执行`iret`指令前必须先弹出这个硬件出错码。    
2. 检查处理程序的CPL是否等于`cs`中最低两位的值(这意味着被中断的进程与处理程序运行在同一特权级)。如果是，`iret`终止执行；否则，转入下一步。    
3. 从栈中装载`ss`和`esp`寄存器，因此，返回到与旧特权级相关的栈。    
4. 检查`ds`,`es`,`fs`及`gs`段寄存器的内容，如果其中一个寄存器包含的选择符是一个段选择符，并且其DPL的值小于`CPL`，那么，清相应的段寄存器。控制单元这么做是为了禁止用户态的程序(CPL=3)利用内核以前所用的段寄存器(DPL=0)。如果不清这些寄存器，怀有恶意的用户态程序就可能利用它们来访问内核地址空间。    

#### 4. 进程切换的五段论

##### 4.1 利用中断进入内核引起用户栈到内核栈的切换

##### 4.2 引发调度时通过内核栈找到PCB

##### 4.3 找到下一个进程的PCB完成PCB的切换

##### 4.4 通过PCB找到内核栈完成内核栈的切换

##### 4.5 通过内核栈找到用户栈利用iret中断返回到用户态程序和用户栈

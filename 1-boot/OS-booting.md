# 操作系统的引导

## 目录
1. [实验内容](#实验内容)
2. [int 0x10中断显示字符或字符串](#2. int 0x10中断显示字符或字符串)
3. [80x86寄存器结构](#3. 80x86寄存器结构)
   - [3.1 段寄存器使用约定](#3.1 段寄存器使用约定)
   - [3.2 EFLAGS标志寄存器](#3.2 EFLAGS标志寄存器)
   - [3.3 GDTR与LDTR](#3.3 GDTR与LDTR)
      - [3.3.1 GDTR](#3.3.1 GDTR)
      - [3.3.2 IDRT](#3.3.2 IDRT)
   - [3.4 保护模式寻址](#3.4 保护模式寻址)
      - [3.4.1 保护模式段式寻址](#3.4.1 保护模式段式寻址)
         - [3.4.1.1 段选择符](#3.4.1.1 段选择符)
         - [3.4.1.2 段描述符](#3.4.1.2 段描述符)
         - [3.4.1.3 段式寻址过程图](#3.4.1.3 段式寻址过程图)
         - [3.4.1.4 进入保护模式](#3.4.1.4 进入保护模式)  
4. [bootsect.s的流程图](#4. bootsect.s的流程图)     
5. [setup.s流程图](5. setup.s流程图)

## 1. 实验内容     
实验内容     
1. 改写`/boot/bootsect.s`能在屏幕上打印诸如"XXX is booting"的提示信息
2. 改写`/boot/setup.s`完成以下功能：
   1. bootsect.s能完成setup.s的载入，并跳转到setup.s开始地址执行。而setup.s向屏幕输出一行"Now we are in SETUP"。
   2. setup.s能够获取至少一个基本的硬件参数(如内存参数、显卡参数、硬盘参数等)，将其存放在内存的特定地址，并输出到屏幕
   3. setup.s不再加载Linux内核，保持上述信息显示在屏幕即可。
3. 有时，继承传统意味着蹩手蹩脚。x86计算机为了向下兼容，导致启动过程比较复杂。请找出x86计算机启动过程中，被硬件强制，软件必须遵守的两个”多此一举“(多找几个也无妨)，说说它们为什么多此一举，并设计更简洁的替代方案。

## 2. int 0x10中断显示字符或字符串

| AH   | 功能         | 调用参数                                     | 返回参数                                     |
| ---- | ---------- | ---------------------------------------- | :--------------------------------------- |
| 0x03 | 读光标位置      | BH=页号                                    | DH=光标行号，DL=光标列号                          |
| 0x0e | 显示字符(光标前移) | AL=字符 BL=前景色                             |                                          |
| 0x13 | 显示字符串      | **ES:BP**=字符串地址 CX=字符串长度                     BH=页号BL=属性                                                              AH=0 AH=1 AH=2 AH=3 | 0：光标返回起始位置                                    1：光标跟随移动                                               2：光标返回起始位置                                    3：光标跟随移动 |

## 3. 80x86寄存器结构

80x86寄存器 CPU共有一般分为5类：

1. 数据寄存器
2. 段寄存器
3. 控制寄存器
4. 指针寄存器
5. 段基址寄存器

具体分类如下：

```register
80x86 registers
|——通用寄存器
|	|——数据寄存器
|	|	|——EAX
|	|	|	|——AX -> |AH|AL|
|	|	|——EBX
|	|	|	|——BX -> |BH|BL|
|	|	|——ECX
|	|	|	|——CX -> |CH|CL|
|	|	|——EDX
|	|		|——DX -> |DH|DL|
|	|
|	|——指针寄存器
|	|	|——堆栈指针寄存器
|	|	|	|——ESP
|	|	|	|	|——SP
|	|	|——基址指针寄存器
|	|		|——EBP
|	|			|__BP
|	|
|	|——变址寄存器
|		|——源变址寄存器
|		|	|——ESI
|		|	|	|——SI
|		|——目的变址寄存器
|			|——EDI
|				|——DI
|
|——控制寄存器
|	|——指令指针寄存器
|	|	|——EIP
|	|	|	|——IP
|	|——标志寄存器
|	|	|——EFLAGS
|	|	|	|——FLAGS
|	|——控制寄存器0
|	|	|——CR0
|	|——控制寄存器1
|	|	|——CR1
|	|——控制寄存器2
|	|	|——CR2
|	|——控制寄存器3
|		|——CR3
|
|——段寄存器
|	|——代码段寄存器
|	|	|——CS
|	|——数据段寄存器
|	|	|——DS
|	|——堆栈段寄存器
|	|	|——SS
|	|——附加段寄存器
|		|——ES
|		|——FS
|		|——GS
|
|——段基址寄存器
|	|——全局描述符表寄存器
|	|	|——GDTR
|	|——中断描述符表寄存器
|	|	|——IDTR
|	|——局部描述符表寄存器
|	|	|——LDTR
|	|——任务状态寄存器
|		|——TR
```

### 3.1 段寄存器使用约定

| 访问存储区类型    | 缺省段寄存器 | 可指定段寄存器  | 段内偏移地址来源    |
| ---------- | ------ | -------- | ----------- |
| 取指令码       | CS     | 无        | IP          |
| 堆栈操作       | SS     | 无        | SP          |
| BP用作基地址寄存器 | SS     | CS DS ES | 依寻址方式寻找有效地址 |
| 串操作源地址     | DS     | CS DS ES | SI          |
| 串操作目的地址    | ES     | 无        | DI          |
| 一般数据存取     | DS     | CS DS ES | 依寻址方式寻找有效地址 |

### 3.2 EFLAGS标志寄存器

```register
31                             18 17 16 15 14 13 12 11 10 9  8  7  6  5  4  3  2  1  0
+-------------------------------+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                               |V |R |0 |N | IO  |O |D |I |T |S |Z |0 |A |0 |P |1 |C |
|                               |M |F |  |T | PL  |F |F |F |F |F |F |  |F |  |F |  |F |
+-------------------------------+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

1. CF(Carry Flag)：进位标志位
2. PF(Parity Flag)：奇偶标志位
3. AF(Assistant Flag)：辅助进位标志位
4. ZF(Zero Flag)：零标志位
5. SF(Signal Flag)：符号标志位
6. IF(Interrupt Flag)：中断允许标志位，由`CLI`，`STI`两条指令来控制；设置IF位使CPU可识别外部(可屏蔽)中断请求，复位IF位则禁止中断；IF位对不可屏蔽外部中断和故障中断的识别没有任何作用
7. DF(Direction Flag)：方向标志位，由`CLD`，`STD`两条指令控制；复位DF标志位，字符串操作指令中`SI`，`DI`值自增；设置DF位字符串操作指令中`SI`，`DI`值自减
8. OF(Overflow Flag)：溢出标志位
9. IOPL(I/O Privilege Level)：I/O特权级字段，宽度2位
10. NT(Nested Task)：控制中断返回指令`IRET`

### 3.3 GDTR与LDTR

#### 3.3.1 GDTR

```register
     47                                               16 15                        0
     +--------------------------------------------------+---------------------------+
GDTR |           32位线性基地址                          |        16位表长度          |
     +--------------------------------------------------+---------------------------+
```

加载GDTR寄存器指令

```assembly
!	           gdt_48
! 47              16 15         0
!+------------------+-----------+
!|   32位线性基地址  | gdt表长度  | gdt_48
!+------------------+-----------+
gdtr gdt_48
```

`gdtr`用于加载全局描述符表寄存器GDTR。它的操作数(gdt_48)有6个字节。前2字节(字节0-1)是描述表的字节长度值；后4字节(字节2-5)是描述符表的32位线性基地址。

#### 3.3.2 IDRT

IDRT同GDTR

### 3.4 保护模式寻址

#### 3.4.1 保护模式段式寻址

不再采用`segment<<4+offset`的实模式段式寻址模式。

##### 3.4.1.1 段选择符

段寄存器是`选择子`，结构如下

```register
15                          3 2 1     0
+----------------------------+--+--+--+
|        描述符索引           |TI| RPL |		段寄存器/选择子
+----------------------------+--+--+--+
```

1. RPL(Requestor's Privilege Level)，请求者特权级
2. TI(Table Indicator)，表指示器，用于指定选择符所引用的描述符表。TI=0，指定GDT表；TI=1，指定当前的LDT表
3. 描述符索引用于选择指定描述符表中的其中一个。处理器将该索引值乘上8，并加上描述符表的基地址即可访问表中指定的段描述符。

##### 3.4.1.2 段描述符

段描述符放在描述符表中。每一个段描述符占8个字节。

下面是代码段描述符的字节分布：

```register
   63          54 53 52 51 50       48 47 46  44  43    40 39             32
   +-------------+--+--+--+--+--------+--+----+--+--------+----------------+
   | BaseAddress |G |B |0 |A |Segment |P | D  |S |  TYPE  | BaseAddress    | 
   |   31...24   |  |  |  |V | Limit  |  | P  |  |        |   23...16      |
   |             |  |  |  |L | 19...16|  | L  |  |        |                |
   +-------------+--+--+--+--+--------+--+----+--+--------+----------------+
   31                               17 16                                  0
   +----------------------------------+------------------------------------+
   |            BaseAddress           |                Segment             |                 
   |             15...0               |                 Limit              |
   |                                  |                 15...0             |
   +----------------------------------+------------------------------------+
```

##### 3.4.1.3 段式寻址过程图

虚拟基址经过段式寻址方式转化为线性地址，转换过程如下：

![段式寻址方式](https://github.com/Wangzhike/HIT-Linux-0.11/raw/master/1-boot/picture/segment-addressing.jpg)

##### 3.4.1.4 进入保护模式

进入保护模式前需要设置好使用的段描述符表，包括全局描述符表`GDT`和中断描述符表`IDT`

1. `lidt`加载中断描述符表寄存器`IDT`
```asm
!           idt_48
!47       32|31     16|15       0
! -32bit linear addr- | len of idt
lidt idt_48
```
lidt用于加载中断描述符表寄存器(IDT)。它的操作数(idt_48)有6字节。
前2字节(字节0-1)是描述符表的字节长度值；后4字节(字节2-5)是描述符表的32位线性基地址。    

2. `lgdt`加载全局描述符表寄存器`GDT`
```asm
lgdt gdt_48
```
指令格式同`lidt`     

3. lmsw(load machine status word) 切换到保护模式
```asm
mov	ax,#0x0001	! protected mode (PE) bit
lmsw ax
```
加载机器状态字，也就是控制寄存器CR0，其比特位0置1将导致CPU切换到保护模式，并且运行在特权级0中
在Intel公司的手册上建议80386或以上CPU应该使用指令`mov cr0, ax`切换到保护模式。`lmsw`指令
仅用于兼容以前的286CPU。

4. 跳转到内存地址0处的`system`模块

```assembly
jmpi	0,8		! jmp offset 0 of segment 8 (cs)
```

寻址方式如[段式寻址过程图](#段式寻址过程图)所示
## 4. bootsect.s的流程图

![bootsect.s flow](https://github.com/Wangzhike/HIT-Linux-0.11/raw/master/1-boot/picture/boot-flow-1.jpg)	

1. 计算机上电，BIOS初始化中断向量表之后，会将启动设备的第一个扇区(即引导扇区)读入内存地址`0x07c00(31kb)`处，并跳转到此处执行，由此系统的控制权由BIOS转交给bootsect.s。而为了方便加载内核模块，bootsect.s首先将自己移动到`0x90000(576kb)`处。这样的移动是多此一举。	

## 5. setup.s流程图

![setup.s flow](https://github.com/Wangzhike/HIT-Linux-0.11/raw/master/1-boot/picture/boot-flow-2.jpg)			
2. 计算机上电后，BIOS会在物理地址0处开始初始化中断向量表，其中有256个中断向量，每个中断向量占用4个字节，共1KB，在物理内存地址`0x00000-0x003fff`处，这些中断向量供BIOS中断使用。这就要求，如果操作系统的引导程序在加载操作系统时使用了BIOS中断来获取或显示一些信息时，内存中这最开始的1KB数据不能被覆盖。而操作系统的内核代码最好起始于物理内存开始处，这样内核空间的代码地址等于实际的物理地址，便于对内核代码和数据进行操作，这就需要将内核代码加载到内存`0x00000`处。如此就产生了矛盾。所以`bootsect.s`在载入内核模块时，先将其加载到`0x10000`处，之后`setup.s`利用BIOS中断读取完硬件参数，再有`setup.s`将内核模块从`0x10000-0x8ffff`处搬运到`0x00000-0x7ffff`处。这样先加载内核模块到其他地方再移到到内存起始位置是多此一举。
